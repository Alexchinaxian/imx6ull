# 蜂鸣器测试说明

## 问题诊断 🔍

当前系统中**蜂鸣器设备不存在**，导致以下问题：
- ❌ `/sys/class/leds/beep` 不存在
- ❌ `DriverBeep::isAvailable()` 返回 `false`
- ❌ `SystemBeep`、`TimeService`、`AlarmService` 无法播放提示音

## 测试步骤 ✅

### 方法1：使用测试脚本（推荐）

#### 1. 创建模拟蜂鸣器设备

```bash
sudo tools/setup_test_beep.sh
```

这会创建：
- 目录：`/sys/class/leds/beep/`
- 文件：`/sys/class/leds/beep/brightness`

#### 2. 测试SystemBeep各种提示音

```bash
tools/test_system_beep.sh
```

这会依次测试：
- 🔔 初始化完成提示音（滴滴）
- 🔔 配置加载成功（滴）
- 🔔 成功提示音（滴滴滴）
- ⚠️ 警告提示音（滴~滴~）
- 🚨 错误警告音（长响）
- 🔔 关机提示音（滴滴滴滴）

### 方法2：手动测试

```bash
# 1. 创建设备（需要root）
sudo mkdir -p /sys/class/leds/beep
sudo bash -c "echo 0 > /sys/class/leds/beep/brightness"
sudo chmod 666 /sys/class/leds/beep/brightness

# 2. 手动测试蜂鸣（写入255=开，0=关）
echo 255 > /sys/class/leds/beep/brightness  # 开启
sleep 0.5
echo 0 > /sys/class/leds/beep/brightness    # 关闭

# 3. 测试短促蜂鸣2次
for i in {1..2}; do
    echo 255 > /sys/class/leds/beep/brightness
    sleep 0.1
    echo 0 > /sys/class/leds/beep/brightness
    sleep 0.1
done
```

### 方法3：在程序中测试

重启你的主程序，它会在启动时自动调用：

```cpp
g_systemBeep = SystemBeep::getInstance();
if (g_systemBeep && g_systemBeep->isAvailable())
{
    g_systemBeep->playInitComplete();  // 播放"滴滴"提示音
}
```

## 验证结果 ✅

### 成功的标志：
1. ✅ 设备文件存在：`ls -la /sys/class/leds/beep/brightness`
2. ✅ 可以手动控制：`echo 255 > /sys/class/leds/beep/brightness`
3. ✅ 程序日志显示：`[SystemBeep] 🔔 播放初始化完成提示音（滴滴）`
4. ✅ 实际听到蜂鸣声（如果硬件连接）

### 失败的标志：
1. ❌ 日志显示：`Beep device not found: /sys/class/leds/beep`
2. ❌ `isAvailable()` 返回 `false`
3. ❌ 听不到蜂鸣声

## 实际硬件配置 🔧

如果你的IMX6ULL开发板有**真实蜂鸣器硬件**，需要配置实际的GPIO：

### 1. 查找蜂鸣器GPIO编号

检查硬件文档，蜂鸣器通常连接在特定GPIO上，例如：
- **GPIO1_19** → 编号 19
- **GPIO5_1** → 编号 129

### 2. 导出GPIO并配置

```bash
# 假设蜂鸣器在GPIO19
echo 19 > /sys/class/gpio/export
echo out > /sys/class/gpio/gpio19/direction
echo 0 > /sys/class/gpio/gpio19/value

# 测试
echo 1 > /sys/class/gpio/gpio19/value  # 开启蜂鸣器
sleep 0.5
echo 0 > /sys/class/gpio/gpio19/value  # 关闭蜂鸣器
```

### 3. 修改DriverBeep支持GPIO模式

如果需要使用GPIO控制，修改 `DriverBeep.cpp`：

```cpp
// 添加GPIO模式支持
bool DriverBeep::writeBrightness(int value)
{
    // 优先尝试LED模式
    QString ledPath = "/sys/class/leds/beep/brightness";
    if (QFile::exists(ledPath)) {
        // 使用LED模式
        return writeToFile(ledPath, value);
    }
    
    // 回退到GPIO模式
    QString gpioPath = "/sys/class/gpio/gpio19/value";
    if (QFile::exists(gpioPath)) {
        // 使用GPIO模式（0或1）
        return writeToFile(gpioPath, value > 0 ? 1 : 0);
    }
    
    return false;
}
```

## SystemBeep API 参考 📚

### 可用的提示音方法：

```cpp
SystemBeep *beep = SystemBeep::getInstance();

// 1. 初始化完成（滴滴）
beep->playInitComplete();

// 2. 配置加载成功（滴）
beep->playConfigLoaded();

// 3. 成功提示（滴滴滴）
beep->playSuccess();

// 4. 警告提示（滴~滴~）
beep->playWarning();

// 5. 错误警告（长响）
beep->playError();

// 6. 关机提示（滴滴滴滴）
beep->playShutdown();

// 7. 自定义提示音
beep->playCustom(3, 100, 150);  // 3次，每次100ms，间隔150ms

// 8. 启用/禁用蜂鸣器
beep->setEnabled(false);  // 禁用所有提示音
beep->setEnabled(true);   // 启用

// 9. 检查是否可用
if (beep->isAvailable()) {
    qInfo() << "蜂鸣器可用";
}
```

## 时间服务和闹钟服务的蜂鸣器 ⏰

一旦蜂鸣器设备可用，以下功能会自动工作：

### TimeService（时间服务）
- ⏰ **半点提醒**：每30分钟蜂鸣1次
- ⏰ **整点报时**：每小时蜂鸣2次

### AlarmService（闹钟服务）
- 🌅 **起床闹钟**：工作日早上6:00（有节奏铃声）
- 🌙 **睡眠提示**：每天晚上22:00（温和提示音）

## 故障排查 🔧

### 问题1：设备创建后仍然不工作

```bash
# 检查设备权限
ls -la /sys/class/leds/beep/
# 应该显示: -rw-rw-rw- brightness

# 如果权限不对，修复：
sudo chmod 666 /sys/class/leds/beep/brightness
```

### 问题2：无法创建设备（sysfs只读）

在某些系统上，`/sys` 是只读的。解决方案：
1. 使用真实的GPIO设备
2. 修改DriverBeep支持GPIO模式
3. 使用设备树配置实际硬件

### 问题3：听不到声音但设备存在

1. 检查硬件连接
2. 测试GPIO直接控制
3. 检查蜂鸣器电源

## 测试清单 ✅

完成以下测试以验证蜂鸣器功能：

- [ ] 设备文件存在：`/sys/class/leds/beep/brightness`
- [ ] 手动控制成功：`echo 255 > /sys/class/leds/beep/brightness`
- [ ] SystemBeep可用：`isAvailable()` 返回 `true`
- [ ] 启动提示音工作：程序启动时听到"滴滴"
- [ ] 半点提醒工作：每30分钟蜂鸣
- [ ] 起床闹钟工作：工作日早上6:00响铃
- [ ] 睡眠提示工作：每晚22:00提示

---

**作者**: Alex  
**日期**: 2025-10-15  
**相关文件**: 
- `src/core/SystemBeep.cpp`
- `src/drivers/beep/DriverBeep.cpp`
- `tools/setup_test_beep.sh`
- `tools/test_system_beep.sh`

